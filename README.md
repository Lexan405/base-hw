# Задание 1. СУБД

## 1.1. Бюджетирование проектов и финансовая аналитика

Для этой задачи, на мой взгляд, лучше всего подойдёт **реляционная СУБД**, например **PostgreSQL** или **Microsoft SQL Server**.  
Причина в том, что здесь критически важны:

- **Целостность данных**,
- **Чёткая структура** (например, таблицы проектов, статей расходов, бюджетов),
- Поддержка **ACID-транзакций**, что гарантирует корректность финансовых операций.

Кроме того, реляционные СУБД отлично подходят для построения аналитических отчётов с помощью SQL и легко интегрируются с BI-инструментами (например, Power BI, Tableau).

### 1.1.* Хеширование стало занимать много времени — какое API можно использовать?

Если хеширование выполняется внутри СУБД, можно использовать встроенные расширения, например:

- В **PostgreSQL** — расширение `pgcrypto` для безопасного хеширования.
  
Если же хеширование происходит на стороне приложения и тормозит систему, лучше:

- Использовать **ускоренные криптографические библиотеки**, такие как **OpenSSL** или **libsodium**.
- Внедрить **кеширование хешей** через быструю in-memory СУБД, например **Redis**, чтобы избежать повторных вычислений.

---

## 1.2. Лендинги и CRM

Для лендингов и CRM важны **гибкость**, **быстрота** и возможность часто менять структуру данных (например, добавлять новые поля в формы). Здесь лучше подойдут **документо-ориентированные СУБД**, такие как **MongoDB**.

Преимущества:
- Хранение данных в формате JSON-подобных документов,
- Простое масштабирование,
- Быстрые операции записи и чтения,
- Лёгкое управление разнородными формами лидов с разных проектов.

### 1.2.* Можно ли эту задачу закрыть одной СУБД?

**Да**, можно. Например, **MongoDB** подойдёт и для сбора лидов с лендингов, и для работы CRM.  
Каждый лендинг может писать данные в отдельную коллекцию или использовать общий формат с тегами проекта. CRM будет просто агрегировать и обрабатывать эти данные. MongoDB поддерживает гибкие схемы, индексацию и сложные запросы — этого достаточно для обеих задач.

---

## 1.3. База знаний по корпоративным нормам и обучению

Здесь требуется **простая и понятная структура**, возможно, с иерархией (разделы → подразделы → документы).  

Подойдёт **реляционная СУБД**, так как:
- Легко организовать категории и связи,
- Можно управлять правами доступа к разделам,
- Поддерживается полнотекстовый поиск (особенно в PostgreSQL).

Даже **SQLite** может быть достаточен, если база небольшая и используется локально или в простом веб-приложении.

### 1.3.* Можно ли использовать уже существующую СУБД?

**Да**, если в задаче 1.1 уже используется, например, **PostgreSQL**, то туда же можно добавить отдельную **схему** (schema) или набор таблиц для базы знаний.  
Важно логически отделить данные (например, через префиксы или разные схемы), чтобы не смешивать финансовую информацию с обучающими материалами. Это упростит администрирование и снизит затраты на инфраструктуру.

---

## 1.4. Логистика и маршрутизация

В задачах логистики ключевую роль играют **связи между объектами**: склады → объекты → курьеры → маршруты.  

Для таких сценариев идеально подходят **графовые СУБД**, например **Neo4j**, потому что:
- Они оптимизированы для работы с графами,
- Позволяют быстро находить кратчайшие пути,
- Упрощают моделирование сложных отношений.

### 1.4.* Можно ли подключить отдел закупок?

**Да**, если у закупок есть логические связи с логистикой (например: поставщик → склад → объект), их данные можно интегрировать в ту же графовую СУБД. Это даст сквозную видимость цепочки поставок.

Однако, если у закупок преобладает **финансовая или табличная логика** (как в задаче 1.1), то их лучше оставить в реляционной СУБД и настроить **синхронизацию данных** между системами (например, через ETL или API).

---

## 1.5.* Можно ли всё решить одной СУБД?

**Теоретически — да**, но **практически — не всегда целесообразно**.

Самый универсальный кандидат — **PostgreSQL**, потому что он поддерживает:

- Классические реляционные таблицы (для финансов и базы знаний),
- JSON/JSONB-поля и документную модель (для CRM и лендингов),
- Расширение **PostGIS** для геопространственных запросов (маршруты доставки),
- Рекурсивные CTE для эмуляции графов,
- Полноценный полнотекстовый поиск.

Однако такая «универсальная» архитектура может стать:

- Сложной в разработке и поддержке,
- Менее производительной для специфических задач (например, графовые запросы будут медленнее в PostgreSQL, чем в Neo4j).

Поэтому в реальных проектах чаще применяют **полиглотную персистентность**: разные СУБД под разные задачи, но с чёткой интеграцией через API, очереди сообщений или ETL-процессы.

Тем не менее, если компания хочет минимизировать количество технологий и имеет ограниченные ресурсы, **PostgreSQL** — наиболее сбалансированный и мощный выбор.

---

## Задание 2. Типы СУБД для разных задач

### 2.1 Бюджетирование и финансовая отчётность  
Для бюджетов и отчётов лучше использовать **реляционную СУБД**, например **PostgreSQL** или **MySQL**.  
Почему? Потому что там важна точность, нельзя допускать ошибок, и данные должны быть строго структурированы. Реляционные базы поддерживают транзакции (ACID), и можно легко строить отчёты с помощью SQL.

> **2.1\*** Если хеширование тормозит, можно попробовать использовать **Redis** — это быстрая in-memory база, которая ускоряет работу с часто запрашиваемыми данными.

---

### 2.2 Лендинги и CRM  
Для лендингов и CRM подойдут **NoSQL базы**, например **MongoDB**.  
Почему? Потому что данные там могут быть разными (имя, email, UTM-метки и т.д.), и структура может часто меняться. NoSQL гибкие и быстрые для таких задач.

> **2.2\*** Можно ли использовать одну СУБД?  
> Да, можно! Например, **PostgreSQL** умеет работать с JSON (через тип `JSONB`). Тогда можно хранить и структурированные данные (менеджеры, проекты), и гибкие (лиды с лендингов) в одной базе.

---

### 2.3 База знаний (нормы, обучение)  
Здесь подойдёт простая **реляционная СУБД**, например **SQLite** или **PostgreSQL**.  
Данные статичные, структура понятная: разделы → подразделы → документы. Всё можно хранить в таблицах с ссылками.

> **2.3\*** Можно ли использовать уже существующую СУБД?  
> Да! Если у нас уже есть PostgreSQL для финансов или CRM, можно просто создать новую схему (например, `knowledge_base`) и хранить там документы. Это удобно и не требует новых серверов.

---

### 2.4 Логистика (маршруты, курьеры)  
Здесь лучше использовать **графовую СУБД**, например **Neo4j**, потому что нужно работать со связями: курьер → склад → объект.  
Или можно использовать **PostgreSQL с расширением PostGIS**, если важны географические расчёты (расстояния, маршруты).

> **2.4\*** Можно ли подключить отдел закупок?  
> Да, если закупки связаны с логистикой (например, откуда везут материалы), то можно хранить всё в одной базе. Но если закупки требуют строгой финансовой отчётности, лучше держать их отдельно (например, в реляционной СУБД) и синхронизировать данные.

---

### 2.5\* Можно ли всё сделать в одной СУБД?  
Технически — **да**, если взять **PostgreSQL**.  
Он поддерживает:
- Обычные таблицы (для финансов),
- JSONB (для CRM),
- Рекурсивные запросы и ltree (для базы знаний),
- PostGIS (для логистики).

Но на практике, в большой компании, лучше разделить задачи, чтобы не перегружать одну систему и проще масштабироваться.

---

## Задание 3. SQL vs NoSQL

### 3.1 Пять преимуществ SQL перед NoSQL

1. **Надёжность** — SQL базы поддерживают ACID, поэтому данные всегда корректны.
2. **Чёткая структура** — все таблицы и поля описаны заранее, меньше ошибок.
3. **Мощный язык запросов** — можно делать сложные выборки с JOIN, GROUP BY и т.д.
4. **Много готовых инструментов** — например, DBeaver, Power BI, Excel легко подключаются.
5. **Связи между таблицами** — можно легко связать клиента, заказ и товар через внешние ключи.

---

### 3.1\* Что такое NewSQL и чем он лучше?

**NewSQL** — это новые базы, которые берут лучшее от SQL и NoSQL.  
Примеры: **CockroachDB**, **TiDB**, **Google Spanner**.

Преимущества:
- Работают как SQL (поддерживают JOIN, транзакции),
- Но при этом масштабируются горизонтально, как NoSQL (можно добавлять серверы),
- Хорошо работают в облаке и на многих серверах сразу,
- Подходят для больших проектов, где важны и скорость, и точность.

---

## Задание 4. Кластеры

У нас есть **1000 машин** и нужно делать **много вычислений** на **огромных данных**.

### Как выбрать СУБД?
Главный критерий — **умение работать в кластере** и **быстро обрабатывать данные параллельно**.  
Обычные SQL базы (как MySQL) плохо масштабируются на 1000 машин.  
Лучше использовать:
- **NoSQL** (например, Cassandra) — если важна скорость записи,
- Или **аналитические базы** (например, ClickHouse) — если делаем отчёты и агрегации.

Но на самом деле, **СУБД здесь не главное** — важнее **система для расчётов**.

### Какая модель вычислений лучше?
Лучше всего подходит **Apache Spark**.

Почему?
- Он распределяет задачи между всеми 1000 машинами,
- Работает **в памяти**, поэтому очень быстрый,
- Поддерживает Python, SQL, Scala — удобно писать код,
- Может читать данные из HDFS, S3, Kafka, баз и сразу их обрабатывать,
- Если одна машина сломается — Spark сам перезапустит задачу на другой.


> Вывод: для 1000 машин лучше использовать **Spark + распределённое хранилище** (например, HDFS или S3), а СУБД — только как источник или приёмник данных.
