# Задание 1. СУБД

## 1.1. Бюджетирование проектов и финансовая аналитика

Для этой задачи, на мой взгляд, лучше всего подойдёт **реляционная СУБД**, например **PostgreSQL** или **Microsoft SQL Server**.  
Причина в том, что здесь критически важны:

- **Целостность данных**,
- **Чёткая структура** (например, таблицы проектов, статей расходов, бюджетов),
- Поддержка **ACID-транзакций**, что гарантирует корректность финансовых операций.

Кроме того, реляционные СУБД отлично подходят для построения аналитических отчётов с помощью SQL и легко интегрируются с BI-инструментами (например, Power BI, Tableau).

### 1.1.* Хеширование стало занимать много времени — какое API можно использовать?

Если хеширование выполняется внутри СУБД, можно использовать встроенные расширения, например:

- В **PostgreSQL** — расширение `pgcrypto` для безопасного хеширования.
  
Если же хеширование происходит на стороне приложения и тормозит систему, лучше:

- Использовать **ускоренные криптографические библиотеки**, такие как **OpenSSL** или **libsodium**.
- Внедрить **кеширование хешей** через быструю in-memory СУБД, например **Redis**, чтобы избежать повторных вычислений.

---

## 1.2. Лендинги и CRM

Для лендингов и CRM важны **гибкость**, **быстрота** и возможность часто менять структуру данных (например, добавлять новые поля в формы). Здесь лучше подойдут **документо-ориентированные СУБД**, такие как **MongoDB**.

Преимущества:
- Хранение данных в формате JSON-подобных документов,
- Простое масштабирование,
- Быстрые операции записи и чтения,
- Лёгкое управление разнородными формами лидов с разных проектов.

### 1.2.* Можно ли эту задачу закрыть одной СУБД?

**Да**, можно. Например, **MongoDB** подойдёт и для сбора лидов с лендингов, и для работы CRM.  
Каждый лендинг может писать данные в отдельную коллекцию или использовать общий формат с тегами проекта. CRM будет просто агрегировать и обрабатывать эти данные. MongoDB поддерживает гибкие схемы, индексацию и сложные запросы — этого достаточно для обеих задач.

---

## 1.3. База знаний по корпоративным нормам и обучению

Здесь требуется **простая и понятная структура**, возможно, с иерархией (разделы → подразделы → документы).  

Подойдёт **реляционная СУБД**, так как:
- Легко организовать категории и связи,
- Можно управлять правами доступа к разделам,
- Поддерживается полнотекстовый поиск (особенно в PostgreSQL).

Даже **SQLite** может быть достаточен, если база небольшая и используется локально или в простом веб-приложении.

### 1.3.* Можно ли использовать уже существующую СУБД?

**Да**, если в задаче 1.1 уже используется, например, **PostgreSQL**, то туда же можно добавить отдельную **схему** (schema) или набор таблиц для базы знаний.  
Важно логически отделить данные (например, через префиксы или разные схемы), чтобы не смешивать финансовую информацию с обучающими материалами. Это упростит администрирование и снизит затраты на инфраструктуру.

---

## 1.4. Логистика и маршрутизация

В задачах логистики ключевую роль играют **связи между объектами**: склады → объекты → курьеры → маршруты.  

Для таких сценариев идеально подходят **графовые СУБД**, например **Neo4j**, потому что:
- Они оптимизированы для работы с графами,
- Позволяют быстро находить кратчайшие пути,
- Упрощают моделирование сложных отношений.

### 1.4.* Можно ли подключить отдел закупок?

**Да**, если у закупок есть логические связи с логистикой (например: поставщик → склад → объект), их данные можно интегрировать в ту же графовую СУБД. Это даст сквозную видимость цепочки поставок.

Однако, если у закупок преобладает **финансовая или табличная логика** (как в задаче 1.1), то их лучше оставить в реляционной СУБД и настроить **синхронизацию данных** между системами (например, через ETL или API).

---

## 1.5.* Можно ли всё решить одной СУБД?

**Теоретически — да**, но **практически — не всегда целесообразно**.

Самый универсальный кандидат — **PostgreSQL**, потому что он поддерживает:

- Классические реляционные таблицы (для финансов и базы знаний),
- JSON/JSONB-поля и документную модель (для CRM и лендингов),
- Расширение **PostGIS** для геопространственных запросов (маршруты доставки),
- Рекурсивные CTE для эмуляции графов,
- Полноценный полнотекстовый поиск.

Однако такая «универсальная» архитектура может стать:

- Сложной в разработке и поддержке,
- Менее производительной для специфических задач (например, графовые запросы будут медленнее в PostgreSQL, чем в Neo4j).

Поэтому в реальных проектах чаще применяют **полиглотную персистентность**: разные СУБД под разные задачи, но с чёткой интеграцией через API, очереди сообщений или ETL-процессы.

Тем не менее, если компания хочет минимизировать количество технологий и имеет ограниченные ресурсы, **PostgreSQL** — наиболее сбалансированный и мощный выбор.

---


